\documentclass[12pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage{titlesec} % pacote para formatar títulos de seções
\usepackage{tocloft} % pacote para formatar o sumário
\usepackage{hyperref} % pacote para adicionar links no sumário
\usepackage[portuguese]{babel}
\usepackage{setspace}
\usepackage[dvipsnames]{xcolor}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
%% Floating package
\usepackage{floatflt,epsfig,epsf}
\renewcommand{\baselinestretch}{1.5}
% Renomeia os rótulos para as estruturas de controle
\floatname{algorithm}{Algoritmo}
\renewcommand{\listalgorithmname}{Lista de Algoritmos}
\renewcommand{\algorithmicrequire}{\textbf{Requer:}}
\renewcommand{\algorithmicensure}{\textbf{Garante:}}
\renewcommand{\algorithmicend}{\textbf{Fim}}
\renewcommand{\algorithmicif}{\textbf{Se}}
\renewcommand{\algorithmicthen}{\textbf{Então}}
\renewcommand{\algorithmicelse}{\textbf{Senão}}
\renewcommand{\algorithmicfor}{\textbf{Para}}
\renewcommand{\algorithmicdo}{\textbf{faça}}
\renewcommand{\algorithmicwhile}{\textbf{Enquanto}}
\renewcommand{\algorithmicfunction}{\textbf{Função}}

\newcommand{\opt}{\ensuremath{\mathrm{opt}}}
\newcommand{\OPT}{\ensuremath{\mathrm{opt}}}
\newcommand{\Opt}{\ensuremath{\mathrm{opt}}}
\newcommand{\val}{\ensuremath{\mathrm{val}}}

\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolário}[theorem]
\newtheorem{lemma}[theorem]{Lema} 

\newtheorem{definition}[theorem]{Definição}
\newtheorem{problem}[theorem]{Problema}
\newcommand{\scs}{\mbox{{\sc scs}}}
\newcommand{\NP}{\mathit{NP}}
\newcommand{\red}[1]{{\color{red}{#1}}}

% \setlength{\parskip}{0.1cm}
\sloppy
\begin{document}
\begin{center}
  
{\Large {\bf Algoritmos de Aproximação para Problemas de Clustering}
}

\vspace{0.2cm}
{\small 
{\bf Orientadora:} Cristina Gomes Fernandes \\
{\bf Aluno:} João Guilherme Alves Santos
}

\vspace{5mm} 

\begin{abstract}
Este é o projeto de pesquisa do aluno de graduação João Guilherme Alves Santos sob supervisão da Profa.\ Dra.\ Cristina Gomes Fernandes. O objetivo desse projeto é estudar e pesquisar algoritmos de aproximação para problemas de clustering. O material estudado fornecerá a João Guilherme o conhecimento necessário para buscar um futuro mestrado na área.
\end{abstract}

\end{center}
\newpage

\tableofcontents

\newpage

\section{Introdução}

Ao longo do estudo da computação, nos deparamos com significativas dificuldades computacionais na resolução de certos problemas, especialmente em muitos cenários de otimização nos quais buscamos minimizar ou maximizar uma função sobre um domínio específico. Nesse contexto, algoritmos de aproximação surgiram para que pudéssemos sacrificar a otimalidade para encontrar, eficientemente, uma solução cujo valor garante uma relação pré-estabelecida com o valor ótimo. Em geral, definimos o valor ótimo de uma instância $I$ de um problema como \opt($I$).

Clustering são problemas cujo objetivo é agrupar objetos de maneira que objetos no mesmo cluster apresentam mais semelhanças quando comparados a objetos em clusters diferentes. Tais semelhanças serão definidas pelo problema em questão. Neste projeto, iremos estudar três problemas de clustering: $k$-centros, localização de instalações e $k$-mediana. 



O primeiro deles, o $k$-centros, é um problema clássico de otimização combinatória. Dadas $n$ cidades com distâncias especificadas entre elas e um número $k$, o problema quer determinar qual o melhor jeito de construir $k$ depósitos dentre um conjunto determinado das cidades tais que a maior distância entre uma cidade e o depósito mais próximo seja a menor possível.

Nosso problema é modelado como um grafo completo $G(V,E)$, onde $V$ são as cidades e temos uma função distância~$d$ em que $d(e)$ representa a distância das cidades ligadas pela aresta $e$. O objetivo é encontrar um subconjunto $C \subseteq V$ de tamanho $k$ que minimize $\max_{v\in V}d(v,C)$ sendo $d(v,C) = \min_{u\in C}d(vu)$.

Trabalharemos aqui com a versão métrica do problema em que a função $d$ obedece a desigualdade triangular, ou seja, $d(uv) \leq d(ux) + d(xv)$ para todas as triplas de vértices $u$, $x$, $v$. Veremos que, para qualquer função polinomialmente computável~$\alpha(n)$, não existe $\alpha(n)$-aproximação para a versão não métrica desse problema, assumindo $P\not=\NP$. Hsu e Nemhauser~\cite{HSU1979209} mostraram que não existe algoritmo polinomial com razão de aproximação menor que 2 para o problema do $k$-centros, assumindo $P\not=\NP$. Assim, temos algoritmos que apresentam o melhor desempenho possível: utilizando o método do gargalo, Gonzalez~\cite{GONZALEZ1985293} e independentemente Hochbaum e Shmoys~\cite{HochShmoys'85} desenvolveram um algoritmo polinomial com razão de aproximação igual a 2. 


Localização de instalações é um problema clássico de otimização que determina a melhor localização para instalações, como fábricas ou depósitos, com base em demandas geográficas, custos de abertura de instalações e distâncias de transporte. Além disso, eles podem ser modelados para outras aplicações como problemas de posicionamento de caches em um computador ou problemas de projeto de redes.

Existem várias versões do problema de localização de instalações. O mais simples deles é o de localização de instalações sem capacidades, ou seja, em que as instalações não tem limitações para suprir clientes.

No problema de localização de instalações sem capacidades, temos um conjunto de clientes $D$ e um conjunto de instalações $F$. Para cada cliente $j \in D$ e cada instalação $i \in F$, há um custo $c_{ij}$ em associar o cliente $j$ à instalação $i$. Além disso, existe um custo de abertura $f_i$ para cada instalação $i \in F$. O objetivo do problema é escolher um subconjunto $F' \subseteq F$ que minimize o custo total de abertura das instalações em~$F'$ somado ao custo de associação de cada cliente $j \in D$ à instalação em~$F'$ mais próxima a ele. Em outras palavras, queremos encontrar $F' \subseteq F$ que minimize $\sum_{i\in F'} f_i + \sum_{j \in D} \min_{i\in F'}c_{ij}$.

Diversos métodos podem ser utilizados para aproximar o problema de localização de instalações. Charikar e Guha desenvolveram um algoritmo com razão de aproximação $2.414$ utilizando o método de busca local~\cite{Charikar&Guha'05}.  Esse problema também pode ser modelado como um problema de programação inteira e, por isso, técnicas envolvendo programação linear podem ser aplicadas a ele.  Por exemplo, há algoritmos que fazem o arredondamento de soluções da relaxação linear do programa inteiro para obter uma solução do problema.  Alguns destes algoritmos atingem boas razões de aproximação, por exemplo, chegando a 1.677~\cite{Byrka&Aardal'10}. Entretanto, a melhor aproximação encontrada utiliza de vários métodos, incluindo o primal-dual, e garante uma razão de aproximação 1.488~\cite{LI'13}. Essa não é muito distante do melhor que se poderia encontrar, uma vez que Guha e Khuller mostraram que não existe algoritmo para esse problema com razão de aproximação melhor que 1.463~\cite{GUHA1999228}, a menos que $P = \NP$.

O problema $k$-mediana é muito parecido com o problema de localização de instalações. A diferença aqui é que não temos custo para a abertura de instalações e podemos abrir no máximo $k$ delas. Assim, como no $k$-centros também vamos modelar nosso problema como um grafo e vamos também trabalhar com a versão métrica do problema.

Uma instância do $k$-mediana consiste em um grafo ($F,C$)-bipartido completo, sendo $F$ o conjunto das instalações e $C$ o conjunto das cidades, um número inteiro $k$ positivo que representa a quantidade de instalações que podem ser abertas e um custo $c_{ij}$ de conexão de cada cidade $j$ a cada instalação $i$. Devemos determinar um conjunto $I \subseteq F$ tal que $|I| \leq k$ de instalações a serem abertas e uma função que atribua cada cidade a uma instalação aberta tal que minimize o custo total de conexão.

Dentre os três problemas apresentados, esse é o que tem a maior folga entre o melhor resultado de inaproximabilidade e a razão do melhor algoritmo de aproximação. Jain, Mahdian e Saberi provaram que não existe algoritmo polinomial com razão de aproximação $1+ \frac{2}{e}$ para o $k$-mediana ~\cite{JMS'02}, enquanto a melhor aproximação encontrada tem razão $2.675 + \epsilon$~\cite{BPRST'17}.

\newpage
\section{$k$-Centros}

Vamos definir alguns termos que facilitarão as explicações seguintes. Os vértices do conjunto $C \subseteq V$ de tamanho $k$ serão chamados \emph{centros de cluster}. Os vértices de $V$ serão particionados em $k$ conjuntos chamados \emph{clusters} e cada um deles terá exatamente um centro de cluster. Um vértice estará no mesmo cluster que um centro de cluster mais próximo a ele. Cada cluster terá um \emph{raio} que é a maior distância entre o seu centro e um vértice qualquer dele. O nosso problema se resume a encontrar um conjunto $C$ que minimize o maior desses raios. Denotamos por raio$(C)$ o maior raio de um cluster induzido por $C$.\\
Antes de começar a falar sobre algoritmos de aproximação para o problema dos $k$-centros, vamos mostrar que, assumindo $P\not=\NP$, não existe algoritmo polinomial que resolva nosso problema, ou seja, vamos mostrar que nosso problema é $\NP$-difícil. Para isso, vamos definir o problema do $k$-conjunto dominante.

\begin{definition}
    Seja $G = (V,E)$ um grafo. Um conjunto $D \subseteq V$ é chamado \emph{dominante} se, para todo vértice $u \in V \setminus D$, existe um vértice $v \in D$ tal que $uv \in E$.
\end{definition}

\begin{problem}[$k$-conjunto dominante]
    Dado um grafo $G$ e um inteiro $k$, decidir se $G$ tem um conjunto dominante $D$ tal que $|D| \leq k$.      
\end{problem}
Esse problema é $\NP$-completo, sendo o problema GT2 do famoso livro de Garey e Johnson~\cite{garey1979computers}. Usaremos este problema para mostrar que o problema dos $k$-centros é $\NP$-difícil.

\begin{theorem}\label{theorem:2.1}
    O problema dos $k$-centros para instâncias métricas é $\NP$-difícil.
\end{theorem}

\begin{proof}
    Suponha que exista um algoritmo $A$ que resolve o problema dos $k$-centros em tempo polinomial. Seja $G = (V,E)$ um grafo e $I(G,k)$ uma instância do problema $k$-conjunto dominante. Vamos criar uma instância $I'(G',k,d)$ do problema dos $k$-centros a partir da instância $I$. A instância $I'$ tem como grafo $G'(V,E')$ completo tal que, para todo $e \in E'$, \\
    \[
    d(e) = \begin{cases}
            1, \text{ se } e \in E \\
            2, \text{ caso contrário.} 
            \end{cases}\]\\
    Note que $d$ satisfaz a desigualdade triangular e pode ser obtida de $I$ em tempo polinomial.\\
    O algoritmo aplicado à instância $I'$ encontra uma solução $C$, ou seja, um conjunto de $k$ centros de cluster. \\Se raio$(C)=1$ então todos os vértices estão ligados ao centro do seu cluster com uma aresta de $G$ e assim $C$ é um conjunto dominante em $G$. Como o algoritmo $A$ minimiza o raio de $C$, se raio$(C)=2$, não existe uma solução para $I'$ em que os vértices estejam ligados ao centro do seus clusters apenas por arestas de $G$ e, por isso, não existe um conjunto dominante de tamanho menor ou igual a $k$ em $G$.

    Portanto, conseguimos resolver em tempo polinomial o problema do $k$-conjunto dominante, o que implicaria que $P = \NP$.
\end{proof}

O resultado acima pode ser adaptado para dar um resultado mais forte de inaproximabilidade para a versão geral do problema, não restrita à métrica.
\begin{theorem}
    Seja $\alpha(n)$ uma função computável com $\alpha(n)\geq 1$ para todo $n$. Não existe $\alpha(n)$-aproximação para a versão geral do $k$-centros, onde $n$ é o número de vértices do grafo da instância.
\end{theorem}

\begin{proof}
        A demonstração desse teorema é muito parecida com a do Teorema~\ref{theorem:2.1}. \\
        Seja $G = (V,E)$. Suponha que exista um algoritmo polinomial $A$ que é uma $\alpha(n)$-aproximação do $k$-centros e seja $I(G,k)$ uma instância do problema do $k$-conjunto dominante em que $G$ tem $n$ vértices. Vamos criar uma instância $I'(G',k,d)$ do problema dos $k$-centros a partir da instância $I$. A instância $I'$ tem como grafo $G'(V,E')$ completo tal que, para cada $e \in E'$, \\
    \[d(e) = \begin{cases}
            1, \text{ se } e \in E \\
            \alpha(n)+1, \text{ caso contrário.} 
            \end{cases}\]\\
    Como $\alpha(n)$ é uma função computável, essa instância pode ser construída a partir de $I$ em tempo polinomial. \\
    Se $\alpha(n)=1$, então $d$ obedece a desigualdade triangular e $A$ é um algoritmo polinomial e exato, o que, pelo Teorema~\ref{theorem:2.1}, é absurdo. Então, suponha $\alpha(n)>1$. \\
    O algoritmo aplicado à instância $I'$ encontra uma solução $C$ de tamanho $k$. Como $d(e) = 1$ ou $\alpha(n)+1$ para todo $e \in E'$, então raio$(C)=1$ ou $\alpha(n)+1$.\\
    Se raio$(C)=1$ então todos os vértices estão ligados ao centro do seu cluster com aresta de $G$, e assim $C$ é um conjunto dominante em $G$. \\
    Se raio$(C) = \alpha(n) + 1$, então $\opt(I) \geq \frac{\alpha(n)+1}{\alpha(n)}>1$. Assim, não existe solução $C'$ tal que raio$(C')=1$ e não existe $k$-conjunto dominante em $G'$ que utilize apenas arestas de $G$.
    Portanto, conseguimos resolver o problema do $k$-conjunto dominante em tempo polinomial o que, assumindo que $P \not= \NP$, é um absurdo.
\end{proof}
    Fica, então, explícita a impossibilidade de encontrarmos algoritmos de aproximação para a versão geral do problema dos $k$-centros.\\
    Agora que justificamos o estudo de algoritmos de aproximação para esse problema vamos mostrar um limitante inferior para a razão de aproximação para algoritmos desse problema.
    
    \begin{theorem}
        Seja $\varepsilon \in (0,1]$. Não existe $(2-\varepsilon)$-aproximação para o problema dos $k$-centros.
    \end{theorem}
    A prova do Teorema~\ref{theorem:2.1} essencialmente serve também para esse Teorema, a única diferença é que aqui precisamo assumir a existência de um algoritmo que é uma $(2 - \varepsilon)$-aproximação para o problema dos $k$-centros.

    Começaremos por um algoritmo simples, mas que garante uma boa razão de aproximação.
    
\newpage
\subsection{Algoritmo guloso.}
    Seja $G = (V,E)$ o grafo da instância do problema e $d(e)$ o custo de uma aresta $e \in E$.
    Relembremos a função $d(u,S)$ que é definida para um vértice $u$ e um conjunto $S$ de vértices  por,
    \[ d(u,S) = \min_{v\in S} d(uv)
        \]
    A ideia desse algoritmo guloso se concentrará em, a cada iteração, escolher o vértice $u$ tal que $d(u,C)$ seja o maior possível, sendo $C$ o conjunto dos centros de cluster escolhidos até aquele momento.

    \begin{algorithm}
		\begin{algorithmic}[1]
			\Function{guloso}{$G,d,k$}
			\State Escolha arbitrariamente $u \in V$.
            \State $C \gets \{u\}$.
            \While{$|C| \leq k$}
            \State $v \gets \arg\max_{j \in V} d(j,C)$
            \State $C \gets C \cup \{v\}$
            \EndWhile 
			\State Devolva $C$.
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
    
    \begin{theorem}
        O algoritmo {\sc guloso}$(G,d,k)$ é uma $2$-aproximação do $k$-centros.
    \end{theorem}
    \begin{proof}
        Primeiramente, vamos mostrar que o algoritmo é polinomial. A única linha que não é claramente polinomial é a linha $5$. Para cada vértice $v \in V$, vamos olhar a distância de $|C|$ arestas. Como $|C| \leq |V|$, então iremos olhar a distância de no máximo $|V|^2$ arestas a cada iteração. \\
        Seja $C^*$ um conjunto ótimo de centros de cluster para $I(G,d,k)$. Vamos mostrar que raio$(C) \leq 2\opt(I) $. Perceba que a distância entre dois vértices quaisquer de um mesmo cluster de $C^*$ é no máximo $2\opt(I)$, uma vez que vale a desigualdade triangular.\\ 
        Se há um vértice de $C$ em cada cluster de $C^*$, todos os vértices estão a uma distância de no máximo $2\opt(I)$ de um centro de cluster de $C$. Então raio$(C) \leq 2\opt(I)$. \\
        Senão, suponha sem perda de generalidade que $C_{i-1} = \{ u_1,u_2,\ldots,u_{i-1}\}$ é o $C$ ao final da iteração $i-1$ e cada $u_j$ está em um cluster diferente de $C^*$. Seja $u_i$ o vértice escolhido na iteração $i$ e suponha que ele está no mesmo cluster que um vértice $u_j$ para algum $j=1,\ldots,i-1$. Então, $d(u_i,C_{i-1}) \leq d(u_iu_j) \leq 2\opt(I)$. Como $j$ maximiza $d(v,C_{i-1})$, então raio$(C) \leq 2\opt(I)$.
    \end{proof}
    Vamos mostrar que essa análise é justa, ou seja, existe uma instância $I(G,d,k)$ em que o algoritmo devolve uma solução $C$ tal que raio$(C) = 2 \opt(I)$. \\
    O grafo $G$ contém pelo menos $k+2$ vértices e as arestas têm distância 1 ou 2. O grafo induzido pelas arestas de distância 1 é uma estrela, como mostrado na figura abaixo.
    \[
    \begin{tikzpicture}
        % Number of outer vertices in the star
        \def\n{8}
        
        % Radius of the star
        \def\r{2cm}
        
        % Rotation angle
        \def\rotationangle{90}
        
        % Draw the central vertex
        \draw (0,0) node[circle, draw, minimum size=10pt, inner sep=1.5pt] (center) {};
        
        % Draw the outer vertices, rotated
        \begin{scope}[rotate=\rotationangle]
          \foreach \i in {1,...,\n} {
            \draw (\i*360/\n:\r) node[circle, draw, minimum size=10pt, inner sep=1.5pt] (\i) {};
          }
        \end{scope}
        
        % Connect the central vertex to every outer vertex
        \foreach \i in {1,...,\n} {
          \draw (center) -- (\i);
        }
        \draw (4) node[shift={(0.75,0.2)}] {\rotatebox{30}{\scalebox{1.5}{$\ldots$}}} (4);
      \end{tikzpicture}
      \] \\
      Claramente, o raio de uma resposta ótima dessa instância é 1 e inclui o vértice do centro da estrela como um dos centros de cluster. \\
      Note que se, no algoritmo guloso, o vértice escolhido arbitrariamente for algum dos vértices da ponta dessa estrela o vértice do centro nunca será escolhido. Assim, serão escolhidos apenas vértices da ponta da estrela e como temos mais que $k$ delas, sempre existirá um vértice ligado ao centro do seu cluster com uma aresta de distância 2.
\newpage



\subsection{Método do gargalo}
Os chamados problemas de gargalo são aqueles definidos em grafos com pesos nas arestas tais que a resposta ótima é o peso de uma aresta. \\
Para esse algoritmo será necessário saber o que é um conjunto independente de vértices.
\begin{definition}
    Seja $G = (V,E)$ um grafo. Um conjunto $S \subseteq V$ é um conjunto \emph{independente} se não existe $e \in E$ que tenha ambos os extremos em $S$.
\end{definition}
Seja $I(G,d,k)$ uma instância do problema dos $k$-centros. Vamos supor que as arestas $E = \{e_1,e_2,\ldots,e_{|E|}\}$ de $G$ estejam dispostas de forma que $d(e_i) \leq d(e_{i+1})$ para todo $i \in [|E|-1]$. Como sabemos que é possível ordenar em tempo polinomial, podemos assumir isso. \\
Seja $E_i = \{e_1,e_2,\ldots,e_i\}$ e $G_i = (V,E_i)$. Seja também $i^*$ o menor $i$ tal que $G_i$ tem um $k$-conjunto dominante. Como $G$ é completo, $i^*$ existe. Claramente $d(e_{i^*}) = \opt(I)$, porém não conseguimos encontrar $i^*$ eficientemente, uma vez que não é possível saber se um grafo tem um $k$-conjunto dominante em tempo polinomial, a menos que $P = \NP$. Portanto, vamos usar um conjunto independente maximal para aproximar uma resposta.

\begin{lemma}\label{lemma:2.7}
    Seja $G = (V,E)$ um grafo. Um conjunto independente maximal em $G$ é também um conjunto dominante.
\end{lemma}
\begin{proof}
    Seja $S$ um conjunto independente maximal e suponha, por absurdo, que ele não é um conjunto dominante. Então, existe vértice $u \in V \setminus S$ que não é vizinho de nenhum dos vértices de $S$. Portanto, $S \cup \{u\}$ é também um conjunto independente e $S \subset \{S \cup \{u\}\}$. Contradição, pois $S$ é maximal.
\end{proof}
Então, se encontrarmos um conjunto independente maximal de tamanho $k$ em $G$ teremos um conjunto dominante de mesmo tamanho. No entanto, não conseguimos garantir que iremos encontrar esse conjunto em $G$ e, por isso, vamos definir e usar $G^2$.
\begin{definition}
    Seja $G= (V,E)$ um grafo. $G^2 = (V,E')$ é chamado \emph{quadrado} de $G$ e $E' = E \cup \{uv: \text{distância de u a v em $G$ é $2$}\}$.
\end{definition}
Dada a definição vamos enunciar e provar um lema que nos ajudará no algoritmo.
\begin{lemma}\label{lemma:2.9}
    Seja $G$ um grafo e $G^2$ o seu quadrado. Se $G$ contém um $k$-conjunto dominante então todo conjunto independente maximal em $G^2$ tem tamanho no máximo~$k$.
\end{lemma}
\begin{proof}
    Vamos mostrar pela contrapositiva.\\
    Seja $G = (V,E)$ um grafo e $G^2$ o seu quadrado. Suponha que $G^2$ tem um conjunto independente maximal $S \subset V$ tal que $|S| > k$. Seja $D$ um conjunto dominante em $G$, vamos mostrar que $|D| > k$. \\
    Por definição, não existe um caminho de tamanho $2$ ou uma aresta entre dois vértices de $S$ em $G$. Seja $u \in D$, vamos mostrar que $u$ cobre no máximo $1$ vértice de $S$ em $G$. \\
    Se $u \in S$, o único vértice de $S$ coberto por $u$ é ele mesmo, uma vez que não existe aresta entre dois vértices de $S$ em $G$. \\
    Se $u \not \in S$, $u$ pode cobrir apenas um vértice de $S$, caso cobrisse $2$, digamos $v$ e $w$, existiriam as arestas $uv$ e $uw$ e essas arestas formariam um caminho de tamanho $2$ de $v$ para $w$. Assim, $vw$ é uma aresta em $G^2$ e $v$ e $w$ não podem pertencer a $S$ ao mesmo tempo. \\
    Portanto, $|D| \geq |S| > k$.
\end{proof}
Agora, temos todas as definições e lemas que serão necessário para nosso algoritmo.
\begin{algorithm}
    \begin{algorithmic}[1]
        \Function{gargalo}{$G,d,k$}
        \State $i \leftarrow 0$
        \State $M_0 \leftarrow V$
        \While{$|M_i| > k$}
            \State $i\leftarrow i + 1$
            \State Seja $M_i$ um conjunto independente maximal em $G_i^2$
        \EndWhile
        \State Devolva $M_i$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{theorem}
    O algoritmo {\sc gargalo}$(G,d,k)$ é uma $2$-aproximação do problema dos $k$-centros.
\end{theorem}
\begin{proof}
    Primeiro vamos mostrar que o algoritmo é polinomial. \\
    Como $G_{i^*}$ tem um $k$-conjunto dominante, então o loop vai parar no máximo quando $i=i^*$, pois pelo Lema~\ref{lemma:2.9} qualquer conjunto independente maximal em $G_{i^*}$ encontrado terá tamanho no máximo $k$.
    Também é fácil mostrar que é possível encontrar um conjunto independente maximal em tempo polinomial, um algoritmo simples que começa com um vértice arbitrário e colocamos um vértice que não é adjacente a nenhum vértice do conjunto independente até não ser mais possível é suficiente. \red{Faço um lema para abordar melhor?}\\
    Agora, vamos mostrar que é uma $2$-aproximação. \\
    Seja max$(H)$ o maior valor de uma aresta em um grafo $H$ com peso nas arestas. Seja $i'$ o valor de $i$ ao final do algoritmo e $M_{i'}$ a solução devolvida por ele. Como $M_{i'}$ é um conjunto independente maximal, então pelo Lema~\ref{lemma:2.7} ele é um $k$-conjunto dominante. Pela desigualdade triangular, é fácil notar que max$(G_{i'}^2) \leq 2$  max$(G_{i})$. \\Assim, max$(M_{i'}) \leq $ max$(G_{i'}^2) \leq 2$ max$(G_{i'}) \leq 2$ max$(G_{i^*})= 2 \opt(I)$. 
\end{proof}

\subsection{Inaproximabilidade}

\begin{proof}
    Suponha que exista um algoritmo $A$ que é uma $(2-\varepsilon)$-aproximação para o problema dos $k$-centros em tempo polinomial. Seja $G = (V,E)$ um grafo e $I(G,k)$ uma instância do problema $k$-conjunto dominante. Vamos criar uma instância $I'(G',k,d)$ do problema dos $k$-centros a partir da instância I. A instância $I'$ tem grafo $G'(V,E')$ completo tal que, para todo $e \in E'$, \\
    \[
    d(e) = \begin{cases}
            1, \text{ se } e \in E \\
            2, \text{ caso contrário.} 
            \end{cases}\]\\
    Note que d satisfaz a desigualdade triangular.\\
    O algortimo aplicado à instância I' encontra uma solução C. É fácil perceber que o conjunto $C$, dos centros de clusters, representa um conjunto dominante em $G'$ de tamanho $k$.\\
    Se raio$(C)=1$ então todos os vértices estão ligados aos centros dos seus cluster com uma arestas de $G$, assim $C$ também é um conjunto dominante em $G$. \\ 
    Se raio$(C)=2$, não existe uma solução $C'$ tal que raio$(C') = 1$, uma vez que o algoritmo $A$ garante uma solução com valor no máximo $(2-\varepsilon)\opt(I)$ e, caso existisse, $C$ não satisfaria essa cota. Assim, não existe $k$-conjunto dominante em $G$. \\ 
    Portanto, conseguimos resolver em tempo polinomial o problema do $k$-conjunto dominante, o que é um absurdo.
\end{proof}
\newpage
\bibliographystyle{plain}
\bibliography{aprox.bib}

\end{document}


