\documentclass[12pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage{titlesec} % pacote para formatar títulos de seções
\usepackage{tocloft} % pacote para formatar o sumário
\usepackage{hyperref} % pacote para adicionar links no sumário
\usepackage[portuguese]{babel}
\usepackage{setspace}
\usepackage[dvipsnames]{xcolor}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
%% Floating package
\usepackage{floatflt,epsfig,epsf}
\renewcommand{\baselinestretch}{1.5}
% Renomeia os rótulos para as estruturas de controle
\floatname{algorithm}{Algoritmo}
\renewcommand{\listalgorithmname}{Lista de Algoritmos}
\renewcommand{\algorithmicrequire}{\textbf{Requer:}}
\renewcommand{\algorithmicensure}{\textbf{Garante:}}
\renewcommand{\algorithmicend}{\textbf{Fim}}
\renewcommand{\algorithmicif}{\textbf{Se}}
\renewcommand{\algorithmicthen}{\textbf{Então}}
\renewcommand{\algorithmicelse}{\textbf{Senão}}
\renewcommand{\algorithmicfor}{\textbf{Para}}
\renewcommand{\algorithmicdo}{\textbf{faça}}
\renewcommand{\algorithmicwhile}{\textbf{Enquanto}}
\renewcommand{\algorithmicfunction}{\textbf{Função}}

\newcommand{\opt}{\ensuremath{\mathrm{opt}}}
\newcommand{\OPT}{\ensuremath{\mathrm{opt}}}
\newcommand{\Opt}{\ensuremath{\mathrm{opt}}}
\newcommand{\val}{\ensuremath{\mathrm{val}}}

\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolário}[theorem]
\newtheorem{lemma}[theorem]{Lema} 

\newtheorem{definition}[theorem]{Definição}
\newtheorem{problem}[theorem]{Problema}
\newcommand{\scs}{\mbox{{\sc scs}}}
\newcommand{\NP}{\mathit{NP}}
\newcommand{\red}[1]{{\color{red}{#1}}}

% \setlength{\parskip}{0.1cm}
\sloppy
\begin{document}
\begin{center}
  
{\Large {\bf Algoritmos de Aproximação para Problemas de Clustering}
}

\vspace{0.2cm}
{\small 
{\bf Orientadora:} Cristina Gomes Fernandes \\
{\bf Aluno:} João Guilherme Alves Santos
}

\vspace{5mm} 

\begin{abstract}
Este é o projeto de pesquisa do aluno de graduação João Guilherme Alves Santos sob supervisão da Profa.\ Dra.\ Cristina Gomes Fernandes. O objetivo desse projeto é estudar e pesquisar algoritmos de aproximação para problemas de clustering. O material estudado fornecerá a João Guilherme o conhecimento necessário para buscar um futuro mestrado na área.
\end{abstract}

\end{center}
\newpage

\tableofcontents

\newpage

\section{Introdução}

Ao longo do estudo da computação, nos deparamos com significativas dificuldades computacionais na resolução de certos problemas, especialmente em muitos cenários de otimização nos quais buscamos minimizar ou maximizar uma função sobre um domínio específico. Nesse contexto, algoritmos de aproximação surgiram para que pudessemos sacrificar a otimalidade para encontrar, eficientemente, um ponto cujo valor garante uma relação pré-estabelecida com o valor ótimo.

Clustering são problemas cujo objetivo é agrupar objetos de maneira que objetos no mesmo cluster apresentam mais semelhanças quando comparados a objetos em clusters diferentes. Tais semelhanças serão definidas pelo problema em questão. Neste projeto, iremos estudar três problemas de clustering: $k$-centros, localização de instalações e $k$-mediana. 



O primeiro deles, o $k$-centros, é um problema clássico de otimização combinatória. Dadas $n$ cidades com distâncias especificadas entre elas e um número $k$, o problema quer determinar qual o melhor jeito de construir $k$ depósitos dentre um conjunto determinado das cidades tais que a maior distância entre uma cidade e o depósito mais próximo seja a menor possível.

Nosso problema é modelado como um grafo completo $G(V,E)$, onde $V$ são as cidades e temos uma função distância~$d$ em que $d(e)$ representa a distância das cidades ligadas pela aresta $e$. O objetivo é encontrar um subconjunto $C \subseteq V$ de tamanho $k$ que minimize $\max_{v\in V}d(v,C)$ sendo $d(v,C) = \min_{u\in C}d(vu)$.

Trabalharemos aqui com a versão métrica do problema em que a função $d$ obedece a desigualdade triangular, ou seja, $d(uv) \leq d(ux) + d(xv)$ para todas as triplas de vértices $u$, $x$, $v$. Veremos que, para qualquer função polinomialmente computável~$\alpha(n)$, não existe $\alpha(n)$-aproximação para a versão não métrica desse problema, assumindo $P\not=\NP$. Hsu e Nemhauser~\cite{HSU1979209} mostraram que não existe algoritmo polinomial com razão de aproximação menor que 2 para o problema do $k$-centros, assumindo $P\not=\NP$. Assim, temos algoritmos que apresentam o melhor desempenho possível: utilizando o método do gargalo, Gonzalez~\cite{GONZALEZ1985293} e independentemente Hochbaum e Shmoys~\cite{HochShmoys'85} desenvolveram um algoritmo polinomial com razão de aproximação igual a 2. 


Localização de instalações é um problema clássico de otimização que determina a melhor localização para instalações, como fábricas ou depósitos, com base em demandas geográficas, custos de abertura de instalações e distâncias de transporte. Além disso, eles podem ser modelados para outras aplicações como problemas de posicionamento de caches em um computador ou problemas de projeto de redes.

Existem várias versões do problema de localização de instalações. O mais simples deles é o de localização de instalações sem capacidades, ou seja, em que as instalações não tem limitações para suprir clientes.

No problema de localização de instalações sem capacidades, temos um conjunto de clientes $D$ e um conjunto de instalações $F$. Para cada cliente $j \in D$ e cada instalação $i \in F$, há um custo $c_{ij}$ em associar o cliente $j$ à instalação $i$. Além disso, existe um custo de abertura $f_i$ para cada instalação $i \in F$. O objetivo do problema é escolher um subconjunto $F' \subseteq F$ que minimize o custo total de abertura das instalações em~$F'$ somado ao custo de associação de cada cliente $j \in D$ à instalação em~$F'$ mais próxima a ele. Em outras palavras, queremos encontrar $F' \subseteq F$ que minimize $\sum_{i\in F'} f_i + \sum_{j \in D} \min_{i\in F'}c_{ij}$.

Diversos métodos podem ser utilizados para aproximar o problema de localização de instalações. Charikar e Guha desenvolveram um algoritmo com razão de aproximação $2.414$ utilizando o método de busca local~\cite{Charikar&Guha'05}.  Esse problema também pode ser modelado como um problema de programação inteira e, por isso, técnicas envolvendo programação linear podem ser aplicadas a ele.  Por exemplo, há algoritmos que fazem o arredondamento de soluções da relaxação linear do programa inteiro para obter uma solução do problema.  Alguns destes algoritmos atingem boas razões de aproximação, por exemplo, chegando a 1.677~\cite{Byrka&Aardal'10}. Entretanto, a melhor aproximação encontrada utiliza de vários métodos, incluindo o primal-dual, e garante uma razão de aproximação 1.488~\cite{LI'13}. Essa não é muito distante do melhor que se poderia encontrar, uma vez que Guha e Khuller mostraram que não existe algoritmo para esse problema com razão de aproximação melhor que 1.463~\cite{GUHA1999228}, a menos que $P = \NP$.

O problema $k$-mediana é muito parecido com o problema de localização de instalações. A diferença aqui é que não temos custo para a abertura de instalações e podemos abrir no máximo $k$ delas. Assim, como no $k$-centros também vamos modelar nosso problema como um grafo e vamos também trabalhar com a versão métrica do problema.

Uma instância do $k$-mediana consiste em um grafo ($F,C$)-bipartido completo, sendo $F$ o conjunto das instalações e $C$ o conjunto das cidades, um número inteiro $k$ positivo que representa a quantidade de instalações que podem ser abertas e um custo $c_{ij}$ de conexão de cada cidade $j$ a cada instalação $i$. Devemos determinar um conjunto $I \subseteq F$ tal que $|I| \leq k$ de instalações a serem abertas e uma função que atribua cada cidade a uma instalação aberta tal que minimize o custo total de conexão.

Dentre os três problemas apresentados, esse é o que tem a maior folga entre o melhor resultado de inaproximabilidade e a razão do melhor algoritmo de aproximação. Jain, Mahdian e Saberi provaram que não existe algoritmo polinomial com razão de aproximação $1+ \frac{2}{e}$ para o $k$-mediana ~\cite{JMS'02}, enquanto a melhor aproximação encontrada tem razão $2.675 + \epsilon$~\cite{BPRST'17}.

\newpage
\section{$k$-centros}

Vamos definir alguns termos que facilitarão as explicações seguintes. Os vértices do conjunto $C \subseteq V$ de tamanho $k$ serão chamados de \emph{centros de cluster}. Os vértices de $V$ serão particionados em $k$ conjuntos chamados \emph{clusters} e cada um deles terá exatamente um centro de cluster. Um vértice estará no mesmo cluster que um centro de cluster mais próximo a ele. Cada cluster terá um \emph{raio} que é a maior distância entre o seu centro e um vértice qualquer dele. O nosso problema se resume a encontrar um conjunto $C$ que minimize o maior desses raios. Denotamos por raio$(C)$ o maior raio de um cluster induzido por $C$.\\
Antes de começar a falar sobre algoritmos de aproximação para o problema do $k$-centros, vamos mostrar que, assumindo $P\not=\NP$, não existe algoritmo polinomial que resolva nosso problema, ou seja, vamos mostrar que nosso problema é $\NP$-difícil. Para isso, vamos definir o problema do $k$-conjunto dominante.

\begin{definition}
    Seja $G = (V,E)$ um grafo. Um conjunto $D \subseteq V$ é chamado \emph{dominante} se, para todo vértice $u \in V \setminus D$, existe um vértice $v \in D$ tal que $uv \in E$.
\end{definition}

\begin{problem}[$k$-conjunto dominante]
    Dado um grafo $G$ e um inteiro $k$, decidir se $G$ tem um conjunto dominante $D$ tal que $|D| \leq k$.      
\end{problem}
Esse problema é $\NP$-completo, sendo o problema GT2 do famoso livro de Garey e Johnson~\cite{garey1979computers}, usaremos este problema para mostrar que o problema dos $k$-centros é $\NP$-difícil.

\begin{theorem}\label{theorem:2.1}
    O problema dos $k$-centros para instâncias métricas é $\NP$-difícil.
\end{theorem}

\begin{proof}
    Suponha que exista um algoritmo $A$ que resolve o problema do $k$-centros em tempo polinomial. Seja $G = (V,E)$ um grafo e $I(G,k)$ uma instância do problema $k$-conjunto dominante. Vamos criar uma instância $I'(G',k,d)$ do problema dos $k$-centros a partir da instância I. A instância $I'$ tem grafo $G'(V,E')$ completo tal que, para todo $e \in E'$, \\
    \[
    d(e) = \begin{cases}
            1, \text{ se } e \in E \\
            2, \text{ caso contrário.} 
            \end{cases}\]\\
    Note que d satisfaz a desigualdade triangular.\\
    O algortimo aplicado à instância I' encontra uma solução C. É fácil perceber que o conjunto $C$, dos centros de clusters, representa um conjunto dominante em $G'$ de tamanho $k$. Se raio$(C)=1$ então todos os vértices estão ligados aos centros dos seus cluster com uma arestas de $G$, assim $C$ também é um conjunto dominante em $G$. Como $A$ minimiza esse raio, se raio$(C)=2$, não existe uma solução de $I'$ em que os vértices estejam ligados aos centros dos seus clusters apenas por arestas de $G$ e, por isso, não existe um conjunto dominante de tamanho menor ou igual a $k$ em $G$.

    Portanto, conseguimos resolver em tempo polinomial o problema do $k$-conjunto dominante, o que é um absurdo.
\end{proof}

O resultado acima pode ser adaptado para dar um resultado mais forte de inaproximabilidade para a versão geral do problema, não restrita à métrica.
\begin{theorem}
    Seja $\alpha(n)$ uma função computável com $\alpha(n)\geq 1$ para todo $n$. Não existe $\alpha(n)$-aproximação para a versão geral do $k$-centros.
\end{theorem}

\begin{proof}
        A demonstração desse teorema é muito parecida com a do Teorema~\ref{theorem:2.1}. \\
        Seja $G = (V,E)$. Suponha que exista um algoritmo polinomial $A$ que é uma $\alpha(n)$-aproximação do $k$-centros e seja $I(G,k)$ uma instância do problema $k$-conjunto dominante. Vamos criar uma instância $I'(G',k,d)$ do problema dos $k$-centros a partir da instância I. A instância $I'$ tem grafo $G'(V,E')$ completo tal que, para cada $e \in E'$, \\
    \[d(e) = \begin{cases}
            1, \text{ se } e \in E \\
            \alpha(n)+1, \text{ caso contrário.} 
            \end{cases}\]\\
    Se $\alpha(n)=1$, então $d$ obedece a desigualdade triangular e A é um algoritmo exato, o que, pelo Teorema~\ref{theorem:2.1}, é absurdo. \\
    Então, suponha $\alpha(n)>1$. \\
    O algortimo aplicado à instância I' encontra uma solução C de tamanho $k$. É fácil perceber que o conjunto $C$, dos centros de clusters, representa um conjunto dominante em $G'$. Como $d(e) = 1$ ou $\alpha(n)+1$ para todo $e \in E'$, então raio$(C)=1$ ou $\alpha(n)+1$.\\
    Se raio$(C)=1$ então todos os vértices estão ligados aos centros dos seus cluster com arestas de $G$, assim $C$ também é um conjunto dominante em $G$. \\
    Se raio$(C) = \alpha(n) + 1$, então não existe $C'$ tal que raio$(C')=1$, pois caso existisse ele seria escolhido pelo algoritmo, uma vez que $C'$ é uma solução ótima de custo $1$ e o algoritmo garante uma resposta de valor no máximo $\alpha(n)$ vezes o ótimo, o que não é o caso de $C$. Assim, $G'$ não contém um conjunto dominante de tamanho $k$ que utilize apenas arestas de G. \\
    Portanto, conseguimos resolver o $k$-conjunto dominante em tempo polinomial o que, assumindo $P \not= \NP$, é um absurdo.
\end{proof}
    Fica, então, explicita a impossibilidade de encontrarmos algoritmos de aproximação para a versão geral do problema. \\
    Agora que justificamos o estudo de algoritmos de aproximação para esse problema, podemos começar a falar deles. Começaremos por um algoritmo simples, mas que garante uma boa razão de aproximação.
    
\newpage
\subsection{Algoritmo guloso.}
    Seja $G = (V,E)$ o grafo recebido nosso problema e $c_e$ o custo de uma aresta $e \in E$.
    Relembremos a função d$(u,S)$ que recebe um vértice $u$ e um conjunto de vértices $S$ tal que,
    \[ \text{d}(u,S) = \min_{v\in S} c_{uv}
        \]
    A ideia desse algoritmo guloso se concentrará em, a cada iteração, escolher o vértice u tal que d$(u,C)$ seja a maior possível, sendo $C$ os centros de cluster escolhidos até aquele momento.

    \begin{algorithm}
		\begin{algorithmic}[1]
			\Function{guloso}{$G,c,k$}
			\State Escolha arbitrariamente $u \in V$.
            \State $C \gets \{u\}$.
            \While{$|C| \leq k$}
            \State $v \gets \arg\max_{v \in V} \text{d}(j,C)$
            \State $C \gets C \cup \{v\}$
            \EndWhile 
			\State Devolva $C$.
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
    
    \begin{theorem}
        O algoritmo \sc{guloso}$(G,c,k)$ é uma $2$-aproximação do $k$-centros.
    \end{theorem}
    \begin{proof}
        Primeiramente, vamos mostrar que o algoritmo é polinomial. A única linha que não é claramente polinomial é a linha $5$. Podemos calcular a distância de um conjunto de vértices para todos os outros vértices facilmente apenas com uma pequena modificação no algoritmo de Dijkstra. No começo do algoritmo, no lugar de colocar apenas um vértice na fila de prioridade com distância 0, colocamos todos os vértices do conjunto que queremos. Assim, calculamos a menor distância de todos os vértices para um vértice qualquer do conjunto desejado em tempo $O(|E|\log|V|)$, uma vez que nosso grafo é conexo. Além disso, o algoritmo tem complexidade $O(k|E|\log|V| )$.\\
        Seja $C^*$ o conjunto de centros de cluster de uma resposta ótima. Vamos mostrar que $r=$ raio$(C) \leq 2$ raio$(C^*)=r^*$. Perceba que a distância entre dois vértices quaisquer de um mesmo cluster é no máximo $2r^*$, uma vez que vale a desigualdade triangular.\\ 
        Se em $C$ escolhermos vértices que estão, dois a dois, em cluster diferentes em $C^*$, então, no máximo, a maior distância entre um vértice qualquer e o centro do seu cluster será $2r^*$. \\
        Senão, suponha sem perda de generalidade que $C_{i-1} = \{ u_1,u_2,\ldots,u_{i-1}\}$ é o $C$ ao final da iteração $i-1$ e que todos eles estão em cluster diferentes em $C^*$. Seja $u_i$ o vértice escolhido na iteração $i$ e suponha que ele está no mesmo cluster que um vértice $u_j$ para algum $j=1,\ldots,i-1$. Então, $d(u_i,C) \leq 2r^*$, pois para cada $u_j$ a distância entre quaisquer dois vértices que estão no mesmo cluster que ele em $C^*$ é $\leq 2r^*$, assim se o vértice mais distante de $C_{i-1}$ tem distância no máximo $2r^*$ e a partir desse momento a distância de um vértice qualquer para $C$ apenas diminui, então $r\leq 2r^*$.
    \end{proof}
    Vamos mostrar que essa análise é justa, ou seja, existe uma instância $I(G,d,k)$ em que o algoritmo devolve uma solução $C$ tal que raio$(C) = 2 \opt(I)$. \\
    O grafo G contém mais que $k+1$ vértices e as arestas têm distância 1 ou 2. O grafo induzido pelas arestas de distância 1 é uma estrela, como mostrado na figura abaixo.
    \[
    \begin{tikzpicture}
        % Number of outer vertices in the star
        \def\n{8}
        
        % Radius of the star
        \def\r{2cm}
        
        % Rotation angle
        \def\rotationangle{90}
        
        % Draw the central vertex
        \draw (0,0) node[circle, draw, minimum size=10pt, inner sep=1.5pt] (center) {};
        
        % Draw the outer vertices, rotated
        \begin{scope}[rotate=\rotationangle]
          \foreach \i in {1,...,\n} {
            \draw (\i*360/\n:\r) node[circle, draw, minimum size=10pt, inner sep=1.5pt] (\i) {};
          }
        \end{scope}
        
        % Connect the central vertex to every outer vertex
        \foreach \i in {1,...,\n} {
          \draw (center) -- (\i);
        }
        \draw (4) node[shift={(0.75,0.2)}] {\rotatebox{30}{\scalebox{1.5}{$\ldots$}}} (4);
      \end{tikzpicture}
      \] \\
      Claramente, o raio da resposta ótima dessa instância é 1 e inclui o vértice do centro da estrela como um dos centros de cluster. \\
      Note que se, no algoritmo guloso, o vértice escolhido arbitrariamente for algum dos vértices da ponta dessa estrela o vértice do centro nunca será escolhido. Assim, serão escolhidos apenas vértices da ponta da estrela e como temos mais que $k$ delas, sempre existirá um vértice ligado ao centro do seu cluster com uma aresta de distância 2.
\newpage
\subsection{Método do gargalo}
Os chamados problemas de gargalo são aqueles definidos em grafos com pesos nas arestas tais que a resposta ótima é o peso de uma aresta. \\
Para esse algoritmo será necessário saber o que é um conjunto independente de vértices.
\begin{definition}
    Seja $G = (V,E)$ um grafo. Um conjunto $S \subseteq V$ é um conjunto \emph{independente} se não existe $e \in E$ que tenha ambos os extremos em $S$.
\end{definition}
Seja $I(G,d,k)$ uma instância do problema do $k$-centros. Vamos supor que as arestas $E = \{e_1,e_2,\ldots,e_{|E|}\}$ de $G$ estejam dispostas de forma que $d(e_i) \leq d(e_{i+1})$ para todo $i \in [|E|-1]$. Como sabemos que é possível ordenar em tempo polinomial, podemos assumir isso. \\
Seja $E_i = \{e_1,e_2,\ldots,e_i\}$ e $G_i = (V,E_i)$. Seja também $i^*$ o menor $i$ tal que $G_i$ tem um $k$-conjunto dominante. Como $G$ é um completo, $i^*$ existe. Claramente $d(e_{i^*}) = \opt(I)$, porém não conseguimos encontrar $i^*$ eficientente, uma vez que não é possível saber se um grafo tem um $k$-conjunto dominante em tempo polinomial. Portanto, vamos usar um conjunto independente maximal para aproximar uma resposta.

\begin{lemma}
    Seja $G = (V,E)$ um grafo. Um conjunto independente maximal em $G$ é também um conjunto dominante.
\end{lemma}
\begin{proof}
    Seja $S$ um conjunto independente maximal e suponha, por absurdo, que ele não é um conjunto dominante. Então, existe vértice $u \in V \setminus S$ que não é vizinho de nenhum dos vértices de $S$. Portanto, $S \cup \{u\}$ é também um conjunto independente e $S \subset \{S \cup \{u\}\}$. Contradição, pois $S$ é maximal.
\end{proof}
Então, se encontrarmos um conjunto independente maximal de tamanho $k$ em $G$ teremos um conjunto dominante de mesmo tamanho. No entanto, não conseguimos garantir que iremos encontrar esse conjunto em $G$ e, por isso, vamos definir e usar $G^2$.
\begin{definition}
    Seja $G= (V,E)$ um grafo. $G^2 = (V,E')$ é chamado \emph{quadrado} de $G$ e $E' = E \cup \{uv: \text{distância de u a v em $G$ é $2$}\}$.
\end{definition}
Dada a definição vamos enunciar e provar um lema que nos ajudará no algoritmo.
\begin{lemma}\label{lemma:2.9}
    Seja $G$ um grafo e $G^2$ o seu quadrado. Se $G$ contém um $k$-conjunto dominante então todo conjunto independente maximal em $G^2$ tem tamanho no máximo $k$.
\end{lemma}
\begin{proof}
    Vamos mostrar pela contrapositiva.\\
    Seja $G = (V,E)$ um grafo e $G^2$ o seu quadrado. Suponha que $G^2$ tem um conjunto independente maximal $S \subset V$ tal que $|S| > k$. Seja $D$ um conjunto dominante em $G$, vamos mostrar que $|D| > k$. \\
    Por definição, não existe um caminho de tamanho $2$ ou uma aresta entre dois vértices de $S$ em $G$. Seja $u \in D$, vamos mostrar que $u$ cobre no máximo $1$ vértice de $S$. \\Se $u \in S$, o único vértice de $S$ coberto por $u$ é ele mesmo, uma vez que não existe aresta entre dois vértices de $S$ em $G$. \\
    Se $u \not \in S$, $u$ pode cobrir apenas um vértice de $S$, caso cobrisse $2$, digamos $v$ e $w$, existiriam as arestas $uv$ e $uw$ e essas arestas formariam um caminho de tamanho $2$ de $v$ para $w$. Assim, $v$ e $w$ não podem pertencer a $S$ ao mesmo tempo. \\
    Portanto, $|D| \geq |S| > k$.
\end{proof}
Agora, temos todas as definições e lemas que serão necessário para nosso algoritmo.
\begin{algorithm}
    \begin{algorithmic}[1]
        \Function{gargalo}{$G,d,k$}
        \State $i \leftarrow 0$
        \State $M_0 \leftarrow V$
        \While{$|M_i| > k$}
            \State $i\leftarrow i + 1$
            \State Seja $M_i$ um conjunto independente maximal em $G_i^2$
        \EndWhile
        \State Devolva $M_i$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{theorem}
    O algoritmo {\sc gargalo}$(G,d,k)$ é uma $2$-aproximação do problema do $k$-centros.
\end{theorem}
\begin{proof}
    Primeiro vamos mostrar que o algoritmo é polinomial. \\
    Como $G_{i^*}$ tem um $k$-conjunto dominante, então o loop vai parar no máximo quando $i=i^*$, pois pelo Lema~\ref{lemma:2.9} qualquer conjunto independente maximal em $G_{i^*}$ encontrado terá tamanho pelo menos $k$.
    Também é fácil mostrar que é possível encontrar um conjunto independente maximal em tempo polinomial, podemos começar com um vértice só e colocar arbitrariamente vértices que não sejam vizinhos.
\end{proof}
\newpage
\bibliographystyle{plain}
\bibliography{aprox.bib}

\end{document}


