Nessa seção falaremos sobre o algoritmo de busca local com trocas unitárias para o problema das $k$-medianas. Esse algoritmo foi estudado na Seção 9.2 do livro WS2011 e foi desenvolvido por Arya, Garg, Khandekar, Meyerson, Munagala e Pandit~\cite{AryaLocal}.

Numa instância do problema das $k$-medianas o custo de transporte está definido apenas para um cliente e uma instalação.
Definimos o custo de transporte entre duas instalações como o menor custo de transporte entre essas duas instalações passando por um cliente qualquer. Então a desigualdade triangular valerá da seguinte forma: para todo $i,j,k \in F \cup D$,
\[ c_{ij} \leq c_{ik} + c_{kj}.\]

Um algoritmo de busca local começa com uma solução viável para o problema e checa se alguma alteração local melhora o custo da solução atual. Caso essa melhora ocorra, essa alteração é feita. Esse processo se repete até que não exista alteração que melhore o custo da solução corrente. A solução resultante é chamada de \emph{localmente ótima}. O tempo de execução de uma implementação dessa ideia e a qualidade da solução obtida dependem da definição adotada de alteração local. Quanto mais abrangente essa definição, melhor a solução, porém em geral mais lento será o algoritmo. Quanto mais restrita a definição, mais rápido o algoritmo, porém pior em geral a qualidade da solução final. Usualmente adotam-se restrições mínimas que garantam a polinomialidade do algoritmo.

O algoritmo que descreveremos contará apenas com operações de troca em que fechamos uma instalação aberta e abrimos uma instalação fechada. Operações que exclusivamente abram ou fechem instalações não são viáveis, uma vez que apenas abrir uma instalação faz com que nossa solução se torne inviável e é fácil notar que somente fechar alguma instalação não melhora o valor da solução. A solução inicial terá  $k$ instalações abertas escolhidas de maneira arbitrária. Para garantir a polinomialidade, uma operação só será feita se diminuir o custo da solução atual em uma razão de $1-\delta$, para um $\delta>0$. Como essa solução não é necessariamente localmente ótima, iremos chamá-la de solução \emph{quase localmente ótima}. Ao final, mostraremos que, para um $\eps > 0$, o algoritmo é uma $5(1 + \epsilon)$-aproximação para o problema das $k$-medianas, onde o $\delta$ será escolhido em função do $\epsilon$ e o consumo de tempo do algoritmo será afetado pelo valor de $\delta$.

Vamos mostrar que {\sc BuscaLocal$_\eps$-AGKMMP} é uma $(5 + \eps)$-aproximação para o problema das $k$-medianas.
\begin{algorithm}[H]
    \caption{\sc BuscaLocal$_\eps$-AGKMMP$(F,D,c,k)$}
    \begin{algorithmic}[1]
        \State $\delta \gets \frac{\eps}{(5+\eps)k}$
        \State Escolha arbitrariamente $S' \subseteq F$ com $|S'| = k$
        \Repeat
        \State $S\gets S'$
        \If{existem $i \in S$ e $i' \in F\setminus S$ tal que \\ \hspace{3cm} custo$(S\setminus \{i\} \cup \{i'\}) < (1-\delta) $ custo$(S)$}
        \State $S' \gets S \setminus \{i\} \cup \{i'\}$
        \EndIf
        \Until $S=S'$
        \State \Return $S$
    \end{algorithmic}
\end{algorithm}

\begin{theorem}
    A solução $S$ devolvida por {\sc BuscaLocal$_\eps$-AGKMMP} tem custo no máximo $(5+\eps)$ o ótimo.
\end{theorem}

\begin{proof}
Seja $I(F,D,c,k)$ a instância recebida e $S$ a solução devolvida pelo algoritmo. Seja $S^* \subseteq F$ com $|S^*| = k$ tal que custo$(S^*) = \opt(I)$. Seja $\sigma : D \rightarrow S$ com $\sigma(j) \coloneqq \arg\min_{i \in S} c_{ij}$ e $\sigma^* : D \rightarrow S^*$ com $\sigma^*(j) \coloneqq \arg\min_{i\in S^*} c_{ij}$. Além disso, seja $\phi:S^* \rightarrow S$ com $\phi(i^*) \coloneqq \arg\min_{i \in S} c_{i^*i}$.

A priori, iremos construir um conjunto de $k$ trocas que serão chamadas de trocas \emph{cruciais}. Como $S$ é quase localmente ótima, então nenhuma dessas trocas pode melhorar o custo da solução $S$ em uma razão melhor que $ 1- \delta$. Vamos criar uma particionamento $\{Z,O,T\}$ das instalações em $S$ que será fundamental para construirmos as trocas cruciais. Uma instalação $i \in S$ pertence a 
\begin{enumerate}[i.]
\item $Z$ se $|\{i^* \in S^* : \phi(i^*) = i\}| = 0$;
\item $O$ se $|\{i^* \in S^* : \phi(i^*) = i\}| = 1$;
\item $T$ se $|\{i^* \in S^* : \phi(i^*) = i\}| > 1$.
\end{enumerate}
Vamos também criar um particionamento $\{O^*,T^*\}$ de $S^*$. Uma instalação $i^* \in S^*$ pertence a $O^*$ se $\phi(i^*) \in O$ e, caso contrário, pertence a $T^*$. Note que $|O| = |O^*|$. Consequentemente $|T^*| = |T\cup Z|$. Além disso, como cada instalação de $T$ é imagem de pelo menos duas instalações de $T^*$ em $\phi$, então $|T| \leq \frac{|T^*|}{2}$ e, portanto, $|Z| \geq \frac{|T^*|}{2}$.

Agora, vamos construir as trocas cruciais. Para cada $i^* \in O^*$, criaremos uma troca com o par $(\phi(i^*),i^*)$ que gera uma solução $S\setminus \set{\phi(i^*)} \cup \set{i^*}$. Além disso, vamos criar uma coleção com $|T^*|$ trocas, em cada uma delas retiraremos uma instalação de $Z$ e colocaremos uma instalação de $T^*$. Essas trocas podem ser escolhidas arbitrariamente, contanto que cada instalação de $T^*$ apareça uma vez e cada instalação de $Z$ apareça no máximo duas vezes, isso é possível, uma vez que $|T^*| \leq 2 |Z|$.

Considere uma troca crucial onde trocamos a instalação $i \in S$ pela instalação $ i^* \in S^*$. Seja $S' \coloneqq S \setminus \set{i} \cup \set{i^*}$. Vamos construir a função de associação $\sigma' : D \rightarrow S'$. Para cada cliente $j$ tal que $\sigma^*(j) \neq i^*$ e $\sigma(j) \neq i$, tome $\sigma'(j) \coloneqq \sigma(j)$. Para cada cliente $j$ tal que $\sigma^*(j) = i^*$, tome $\sigma'(j)\coloneqq i^*$. Para cada cliente $j$ tal que $\sigma^*(j) \neq i^*$ e $\sigma(j)=i$, tome $\sigma'(j) \coloneqq \phi(\sigma^*(j))$. Note que isso não funciona se $\phi(\sigma^*(j)) = i$, então vamos mostrar que isso não acontece. Suponha por absurdo que $\phi(\sigma^*(j))=i$. Por definição, sabemos que $i$ não pode pertencer a $Z$. Como nas trocas cruciais as instalações que serão fechadas são sempre de $O$ ou $Z$, então $i$ pertence a $O$. Entretanto, existe apenas uma instalação $h$ em $O^*$ tal que $\phi(h) = i$ que é $h = i^*$ e, portanto, $\sigma^*(j) = i^*$ o que é uma contradição. Assim, vale que 
\begin{subequations}
    \begin{align*}
        \text{custo}(S') - \text{custo}(S) &\leq \sum_{j \in D} c_{\sigma'(j)j} - \text{custo}(S) \\
        & = \sum_{j:\sigma^*(j) = i^*} (c_{\sigma^*(j)j} - c_{\sigma(j)j}) \ + \sum_{\substack{j : \sigma^*(j)\neq i^*,\\ \sigma(j) = i}} (c_{\phi(\sigma^*(j))j} - c_{\sigma(j)j}).
    \end{align*}
\end{subequations}

Primeiro, vamos encontrar um limitante superior para o segundo somatório. Pela desigualdade triangular, temos que $c_{\phi(\sigma^*(j))j} \leq c_{\phi(\sigma^*(j))\sigma^*(j)}+c_{\sigma^*(j)j}$. Além disso, por definição de $\phi$, vale que $c_{\phi(\sigma^*(j))\sigma^*(j)}\leq c_{\sigma(j)\sigma^*(j)}$. Aplicando a desigualdade triangular novamente, temos $c_{\sigma(j)\sigma^*(j)} \leq c_{\sigma(j)j} + c_{\sigma^*(j)j}$. Juntando essas desigualdades temos que $c_{\phi(\sigma^*(j))j} \leq c_{\sigma(j)j} + 2c_{\sigma^*(j)j}$ e, consequentemente, $c_{\phi(\sigma^*(j))j} - c_{\sigma(j)j} \leq 2c_{\sigma^*(j)j}$. Portanto, vale que
\begin{subequations}
\begin{align*}
    - \delta C &\leq \sum_{j:\sigma^*(j) = i^*} (c_{\sigma^*(j)j} - c_{\sigma(j)j}) \ + \sum_{\substack{j : \sigma^*(j)\neq i^*, \\ \sigma(j) = i}} (c_{\phi(\sigma^*(j))j} - c_{\sigma(j)j}) \\
    &\leq \sum_{j:\sigma^*(j) = i^*} (c_{\sigma^*(j)j} - c_{\sigma(j)j}) \ + 2\sum_{\substack{j : \sigma^*(j)\neq i^*,\\ \sigma(j) = i}} c_{\sigma^*(j)j}
\end{align*}
\end{subequations}
onde $C\coloneqq \text{custo}(S)$.

Como essa desigualdade vale para toda troca crucial, podemos somá-las. Vamos chamar de $i_\ell$ e $i_\ell^*$ a instalação de $S$ e de $S^*$ referentes a troca $\ell$, respectivamente. Portanto,
\begin{subequations}
\begin{align*}
- k \delta C &\leq \sum_{\ell = 1}^k \left(  \sum_{j : \sigma^*(j) = i_\ell^*} (c_{\sigma^*(j)j} - c_{\sigma(j)j}) \ + 2 \sum_{\substack{ j : \sigma^*(j)\neq i_\ell^*,\\  \sigma(j) = i_\ell}} c_{\sigma^*(j)j}     \right) \\
&= \sum_{j\in D} (c_{\sigma^*(j)j} - c_{\sigma(j)j}) + 2 \sum_{\ell = 1}^k \ \sum_{\substack{ j : \sigma^*(j)\neq i_\ell^*,\\  \sigma(j) = i_\ell}} c_{\sigma^*(j)j} \\
&= C^* - C + 2 \sum_{\ell = 1}^k \ \sum_{\substack{ j : \sigma^*(j)\neq i_\ell^*,\\  \sigma(j) = i_\ell}} c_{\sigma^*(j)j}
\end{align*}
\end{subequations}
em que $C^* \coloneqq \text{custo}(S^*)$. Considere o somatório. É evidente que 
\[\sum_{\substack{ j : \sigma^*(j)\neq i_\ell^*,\\  \sigma(j) = i_\ell}} c_{\sigma^*(j)j} \leq \sum_{\substack{j:\sigma(j) = i_\ell}} c_{\sigma^*(j)j}.\]
Cada instalação de $S$ aparece em no máximo duas trocas. Então
\[ \sum_{\ell=1}^k \sum_{j: \sigma(j) = i_\ell} c_{\sigma^*(j)j} \leq 2\sum_{i \in S} \sum_{j: \sigma(j) = i} c_{\sigma^*(j)j} = 2 C^*.\]
Assim, vale que 
\[ - k \delta C \leq C^* - C + 2 \sum_{\ell = 1}^k \ \sum_{\substack{ j : \sigma^*(j)\neq i_\ell^*,\\  \sigma(j) = i_\ell}} c_{\sigma^*(j)j} \leq 5C^* - C,\]
consequentemente, 
\[C \leq \frac{5C^*}{1 - k\delta} = (5+\epsilon)C^*\]
em que a igualdade vale uma vez que $\delta = \frac{\epsilon}{(5+\epsilon)k}$.
\end{proof}
Agora, é necessário mostrar que o algoritmo roda em tempo polinomial.

\begin{theorem}
    O algoritmo {\sc BuscaLocal$_\eps$-AGKMMP} toma tempo polinomial para executar.
\end{theorem}
\begin{proof}
    Claramente, todas as operações podem ser feitas em tempo polinomial, precisamos apenas mostrar que o algoritmo sempre executa um número polinomial de operações.
    Podemos assumir sem perda de generalidade que todos os custos são inteiros. Seja $M$ o valor da solução inicial. Note que se existir um inteiro $\rho$ tal que $(1-\delta)^\rho M < 1$, então o algoritmo não fará mais que $\rho$ operações. Por uma desigualdade conhecida, sabemos que $(1 - \delta)^{\frac{1}{\delta}} \leq \frac{1}{e}$. Quando elevamos tudo por $\ln M$ temos $(1- \delta)^{\frac{1}{\delta}\ln M} \leq \frac{1}{M}$ e, portanto, vale que $ (1- \delta)^{\frac{1}{\delta}\ln M}M \leq 1$, como $(1-\delta)$ é estritamente menor que 1, então $\frac{1}{\delta}\ln M + 1$ iterações são suficientes para terminar o programa. Perceba que $\ln M$ é polinomial no tamanho da instância, uma vez que $\ln M$ está apenas a uma constante de $\log M$ e $M$ é no máximo a soma de todos os custos. Como precisamos de $\log$ soma dos custos bits para guardar a instância, então $\log M$ é polinomial no tamanho da instância.
\end{proof}